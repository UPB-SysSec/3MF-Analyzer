"""Mutates the models defined in base_models."""

# pylint: disable=wildcard-import,unused-wildcard-import

from copy import deepcopy
from typing import Generator

from ...utils import multithread_generators
from .base import ComplexType
from .complex_types import *
from .simple_types import *

REFERENCE_TYPES = (
    ST_UriReference,
    ST_ResourceID,
    ST_ResourceIDs,
    ST_ResourceIndex,
    ST_ResourceIndices,
    ST_Path,
)


class Mutator:
    """Mutates a given complex type object.
    For specifics see functions called by Mutator.mutate()."""

    def __init__(self, source_object: ComplexType) -> None:
        self.source_object = source_object

    def copy(self):
        """Returns a deep copy of the source object."""
        return deepcopy(self.source_object)

    def _drop_attributes(self) -> Generator[list[ComplexType], None, None]:
        """Drops each attribute one after the other."""
        for index, _ in enumerate(self.source_object.attributes):
            res = self.copy()
            res.mutation_information = {
                "type": "Attribute Dropped",
                "associated_object": res.attributes[index],
            }
            res.attributes = res.attributes[:index] + res.attributes[index + 1 :]
            yield [res]

    def _regenerate_attributes(
        self, valid: bool = False
    ) -> Generator[list[ComplexType], None, None]:
        """Regenerates/Replaces each attribute one after the other,
        valid determines if the value is valid or not."""
        for index, (attribute_name, value) in enumerate(self.source_object.attributes):
            prev_attributes = self.source_object.attributes[:index]
            next_attributes = self.source_object.attributes[index + 1 :]

            for new_value in value.create(valid=valid):
                res = self.copy()
                new_attribute = (attribute_name, new_value)
                res.mutation_information = {
                    "type": f"Attribute Replaced with {'V' if valid else 'Inv'}alid",
                    "associated_object": new_attribute,
                }
                res.attributes = prev_attributes + [new_attribute] + next_attributes
                yield [res]
                break

    def _duplicate_attributes(self) -> Generator[list[ComplexType], None, None]:
        """For each attribute generate a second valid one with the same name.
        If attribute can be generated by its type use that.
        Else just duplicate the existing attribute."""
        for attribute_name, value in self.source_object.attributes:
            _created_value = False
            for new_value in value.create(valid=True):
                if new_value != value:
                    _created_value = True
                    res = self.copy()
                    new_attribute = (attribute_name, new_value)
                    res.mutation_information = {
                        "type": "Attribute Duplicated (New After)",
                        "associated_object": new_attribute,
                    }
                    res.attributes += [new_attribute]
                    yield [res]
                    # res = self.copy()
                    # res.attributes = [new_attribute] + res.attributes
                    # res.mutation_information = {
                    #     "type": "Attribute Duplicated (New Before)",
                    #     "associated_object": new_attribute,
                    # }
                    # yield [res]
                    break
            if not _created_value:
                res = self.copy()
                res.mutation_information = {
                    "type": "Attribute Duplicated (Same)",
                    "associated_object": (attribute_name, value),
                }
                res.attributes.append((attribute_name, value))
                yield [res]

    def _drop_children(self) -> Generator[list[ComplexType], None, None]:
        """Drops each child one after the other and all at once."""
        if len(self.source_object.children) > 1:
            # if there is just one element, just use the "drop all" version
            for index, _ in enumerate(self.source_object.children):
                res = self.copy()
                res.mutation_information = {
                    "type": "Child Dropped",
                    "associated_object": res.children[index],
                }
                res.children = res.children[:index] + res.children[index + 1 :]
                yield [res]
        # drop all children
        res = self.copy()
        res.mutation_information = {
            "type": "All Children Dropped",
            "associated_object": self.source_object.children,
        }
        res.children = []
        yield [res]

    def _duplicate_children(self) -> Generator[list[ComplexType], None, None]:
        """For each child generate a second valid one with the same ID (if there is an ID).
        If a child exists in VALID_STANDALONE_PARTS use that and change the ID to match.
        Else just duplicate the existing child."""
        for index, child in enumerate(self.source_object.children):
            child: ComplexType
            childs_default_instance = child.create()
            if childs_default_instance:

                _attributes = []
                for name, value in childs_default_instance.attributes:
                    copied_attribute = False
                    if isinstance(value, REFERENCE_TYPES):
                        for source_name, _source_value in child.attributes:
                            if name == source_name:
                                # if value is reference type and child has that attribute,
                                # copy value from child.
                                # else just take attribute from default instance
                                _attributes.append((name, _source_value))
                                copied_attribute = True
                                break
                    if not copied_attribute:
                        _attributes.append((name, value))
                childs_default_instance.attributes = _attributes

                res = self.copy()
                res.children = (
                    res.children[:index] + [childs_default_instance] + res.children[index:]
                )
                res.mutation_information = {
                    "type": "Child Duplicated (New After, Same ID)",
                    "associated_object": childs_default_instance,
                }
                yield [res]

            else:
                res = self.copy()
                res.children = res.children[:index] + [child] + res.children[index:]
                res.mutation_information = {
                    "type": "Child Duplicated (Same)",
                    "associated_object": child,
                }
                yield [res]

    def _mutate_children(self) -> Generator[list[ComplexType], None, None]:
        """Creates a mutator for every child and yields a copy for each child mutation."""
        for index, child in enumerate(self.source_object.children):
            for mutated_child in Mutator(child).mutate():
                res = self.copy()
                res.mutation_information = {
                    "type": "Child Mutated",
                    "associated_object": mutated_child,
                }
                res.children = res.children[:index] + mutated_child + res.children[index + 1 :]
                yield [res]

    def mutate(self) -> Generator[list[ComplexType], None, None]:
        """Mutates a copies the object itself, yields mutations."""
        _generators = []

        # for every attribute: drop, duplicate, change to invalid value
        if self.source_object.attributes:
            _generators += [
                self._drop_attributes(),
                self._duplicate_attributes(),
                self._regenerate_attributes(valid=False),
            ]

        # for every child: drop, duplicate, delegate to make children invalid
        if self.source_object.children:
            _generators += [
                self._drop_children(),
                self._duplicate_children(),
            ]

        yield from multithread_generators(_generators, keep_order=True)

        # leave the recursive call excluded from multithreading, as that caches the results
        # we need to keep the order of results, as otherwise we'd get other testcases
        # (but with the same ID) on every run
        if self.source_object.children:
            yield from self._mutate_children()
